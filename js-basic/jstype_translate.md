# js 类型转换


### 转换规则
js类型转换
|值|转换为: <br>字符串|数字|布尔值|对象|
|----|----|----|----|----|
|undefined <br>null| "undfined"<br>"null"|NaN <br>0|false<br>false|throws TypeError <br>throws TypeError|
|true <br>false| "true"<br>"false"|1 <br>0||new Boolean(true) <br>new Boolean(false) |
|""空字符串 <br>"1.2"(非空,数字)<br>"one"(非空,非数字)| |0 <br>1.2<br>NaN|false<br>true<br>true|new String("") <br>new String("1.2")<br>new String("one") |
|0 <br>-0<br>NaN<br>Infinity<br>-Infinity<br>1|"0"<br>"0"<br>"NaN"<br>"Infinity"<br>"-Infinity"<br>"1" |--|false<br>false<br>false<br>true<br>true<br>true|new Number(0) <br>new Number(-0)<br>new Number(NaN)<br>new Number(Infinity)<br>new Number(-Infinity)<br>new Number(1) |
|{}(任意对象) <br>\[\](任意数组)<br>\[9\]\(1个数字元素\)<br>\['a'\]\(其他数组\)<br>function(){}(任意函数)|参考说明<br>""<br>"9"<br>使用join()方法<br>参考说明|参考说明<br>0<br>9<br>NaN<br>NaN|>true<br>true<br>true<br>true<br>true||


### 显式转换
做显式类型转换最简单的方法就是使用Boolean(),Number(),String()或Object()函数.
```
Number("3") // => 3
String(false) //=>"false" 或者使用false.toString()
Boolean([]) //=>true
Object(3) //=>new Number(3)
```
注意:除了null和undefined之外的任何值都具有toString()方法,这个方法的执行结果通常和String()方法的返回结果一致.如果试图把null或undefined转换为对象,则会抛出一个类型错误(TypeError). Object()函数在这种情况下不会抛出异常:它仅简单返回一个新创建的空对象.

### 隐式转换


js中的某些运算符会做隐式的类型转换.如果"+"运算符的一个操作数是字符串,他将会把另一个操作数转换为字符串.一元"+"运算符将其操作数转换为数字.一元"!"运算符将其操作数转换为布尔值并取反.
```
x+"" //等价于String(x)
+x //等价于Number(x) 也可以写成 x-0
!!x //等价于Boolean(x)
```

##### 对象转换为原始值


对象到布尔值的转换最为简单:所有的对象(包括数组和函数)都转换为true.对于包装对象亦是如此.new Boolean(false)是一个对象而不是原始值,它将转换为true

object-to-string和object-to-number的转换是通过调用待转换对象的一个方法来完成的.这里提到的字符串和数字的转换规则只适用于本地对象(native object).宿主对象(如web浏览器定义的对象)根据各自的算法可以转换成字符串和数字

所有的对象继承了两个方法:
* toString().它的作用是返回一个反映这个对象的字符串.
```
({x:1,y:1}).toString() // => '[object Object]'

//数组将每个元素转换成字符串
[1,2,3].toString() // => '1,2,3'

//函数类(Function class)将用户定义的函数转化为js源码字符串
(function(x){console.log(x)}).toString() //=> 'function (x){console.log(x)}'

//正则返回RegExp对象转换为表示正则表达式直接量的字符串
/\d+/g.toString // => '/\\d+/g'
new RegExp('\d+').toString() //=>'/d+/'


//日期类返回一个可读的日期和字符串
new Date().toString() //=> 'Fri Jan 26 2018 19:53:56 GMT+0800 (CST)'

```

* valueOf()

```
日期类的valueOf()会返回它的一个内部表示(时间戳)

```

js对象到字符串的转换步骤:
* 如果对象具有toString()方法,则调用这个方法.如果它返回一个原始值,js将这个值转换为字符串(如果本身不是字符串的话),并返回这个字符串结果,原始值到字符串的转换间文章开始的表格
* 如果对象没有toString()方法,或者这个方法并不返回原始值,那么js会调用valeOf()方法,如果存在这个方法,js会调用它.如果返回值是原始值,js将这个值转换为字符串(如果本身不是字符串的话),并返回这个字符串结果.
* 否则,js无法从toString()或valueOf()获得一个原始值,因此这时它将抛出一个类型错误异常


js对象到数字的转换
* 如果对象具有valueOf()方法,后者会返回一个原始值,则js将这个原始值转换为数字(如果需要的话),并返回这个数字.
* 否则,如果对象具有toString()方法,后者返回一个原始值,则js将其转换并返回
* 否则,js抛出一个类型错误异常

"+"和"=="应用的对象到原始值的转换包含日期对象一种特殊情形,日期类是js语言核心中唯一预先定义的类.它定义了有意义的像字符串和数字类型的转换.对于日期类来说,通过valueOf()和toString()返回的原始值将被直接使用,而不会被强制转换为数字或字符串




1. 一元加法(+)

一元加法运算符把操作数转化为数字(或者NaN),并且返回这个转换后的数字.如果操作数本身就是数字,则直接返回这个数字

2. 二元加法(+运算符)
二元加法运算符"+"可以对两个数字做加法,也可以做字符串连接操作,当两个操作数都是数字或者字符串的时候,结果是直接相加或者直接进行字符串连接,对于其他情况,需要做一些隐式转换
加号的转换规则优先考虑字符串连接,如果其中一个操作数是字符串或者转换为字符串的对象,另一个操作数将会转化为字符串,加法将进行字符串连接操作.如果两个操作数都不是类字符串(string-like)的,那么都将进行算术加法运算.
从技术上讲,加法操作符的行为表现为:
* 如果其中一个操作数是对象,则对象会遵循对象到原始值的转换规则转换为原始类值,日期对象通过toString()方法执行转换,其他对象则通过valueOf()方法进行转化(如果valueOf()方法返回一个原始值的话).由于多数对象都不具备可用的valueOf()方法,因此他们会通过toString()方法来执行转换
* 在进行了对象到原始值的转换后,如果其中一个操作数是字符串的话,另一个操作数也会转化为字符串,然后进行字符串连接.
* 否则,两个操作数都将转化为数字(或者NaN),然后进行加法操作

```
1+2 //=>3: 加法
"1"+"2" //=>"12":字符串连接
"1"+2 //=>"12": 数字转换为字符串后进行字符串连接
1+{} //=>"1[objct Object]": 对象转换为字符串后进行字符串连接
true+true // =>2: 布尔值转化为数字后做加法
2+null // =>2: null转化为0后做加法
2+undefined //=>NaN: undefined转换为NaN后做加法
```
需要特别注意的是,当加厚运算符和字符串和数字一起使用的时候,需要考虑加法的结合性对运算顺序的影响.也就是说,运算结果是依赖于运算符的运算顺序的
```
1+2+" blind mice" //=> "3 blind mice"
1+(2+" blind mice") //=> "12 blind mice"
```
3. 相等和不等运算符
"=="和""==="运算符用于比较两个值是否相等.两个预算法预先任意类型的操作数,如果操作数相等返回true,否则返回false. "==="用于检测两个操作数是否严格相等."=="运算符,用来检测两个操作数是否相等.



严格相等""==="首先计算其操作数的值,然后比较这两个值,比较过程没有任何类型转换:

* 如果两个值类型不同,则他们不相等
* 如果两个值都是null活在都是undefined,则他们不相等
* 如果两个值都是布尔值ture或者都是布尔值false,则他们相等
* 如果其中一个是NaN,或者两个都是NaN,则他们不相等.NaN和其他任何值都是不相等的,包括它本身. 通过x!==x来判断x是否是NaN,只有在x为NaN的时候,这个表达式的值才为true
* 如果两个值为数字且数字相等,则他们相等,如果一个值为0,另一个值为-0,则他们同样相等
* 如果两个值为字符串,且所含的对应位上的16位数完全相等,则他们相等.
* 如果两个引用值指向同一个对象,数组或者函数,则他们是相等的.如果指向不同的对象,则他们是不相等的,尽管两个对象具有完全一样的属性


"=="运算符的比较不严格,如果量操作数不是同一类型,那么相等运算符会尝试进行一些转换,然后进行比较.
* 如果两个操作数的类型相同,则和上文所述的严格相等的比较规则一样.如果严格相等,那么比较结果为相等.如果不严格相等,则比较结果为不相等
* 如果两个操作数类型不同,"=="相等操作符也可能会认为他们相等.检查相等将会遵守如下规则和类型转换:
  - 如果一个值是null,另一个是undefined,则他们相等
  - 如果一个值是数字,另个一是字符串,先将字符串转换为数字,然后使用转换后的值进行比较
  - 如果其中一个值是true,则将其转换为1在进行比较.如果其中一个值是false,则将其转换为0再比较.
  - 如果一个值是对象,另个一值是数字或者字符串,则先将对象转换为原始值,然后进行比较.对象通过toString()方法或者valueOf()方法转换为原始值.js语言核心的内置类首先尝试使用valueOf(),再尝试使用toString(),除了日期类,日期类只使用toString()转换.那些不是js语言核心的对象则通过各自的实现中定义的方法转换为原始值
  - 其他不同类型之间的比价破均不相等
  
```
"1" == true //=> true 布尔值ture首先转化为数字1,然后再执行比较.接下来"1"也转换成数字1,因为两个数字的值相等,因此比较结果为true
```

4. 比较运算符
比较操作符的操作数可能是任意类型.然而,只有数字和字符串才能真正执行比较操作.因此那行不是数字和字符串的操作数都将进行类型转换,类型转换的规则如下:
* 如果操作数是对象,那么这个对象安装转换规则转换为原始值(如果valueOf()返回一个原始值,那么直接使用这个原始值.否则,使用toString()的转换结果进行比较)
* 在对象转换为原始值之后,如果两个操作符都是字符串,那么将依照字母表的顺序对两个字符串进行比较,"字母表顺序"是指组成这个字符串的16位Unicode字符的索引顺序.
* 在对象转换为原始值之后,如果至少有一个操作数不是字符串,那么两个操作数都将转换为数字进行数值比较.0和-0是相等的.Infinity比其他任何数字都大(除了Infinity本身),-Infinity比任何数字都小(除了它本身).如果其中一个操作数是(或转换后是)NaN,那么比较操作符总是返回false

```
1+2 // =>3
"1"+"2" //=>"12"
"1"+2 //=>"12" 字符串连接, 2转换成"2"
11 < 3 // false,数字的比较
"11" < "3" //=> true, 字符串比较
"11" < 3 // => false,数字的比较
"one" < 3 //=> false,数字的比较,"one"转换成NaN
```


对于非日期对象
|运算符|step1|step2|step3|
|----|----|----|----|
|==,+,-|valueOf()|toString()|Number()转换成number原始值|
|>,<|valueOf()|toString()||



对于日期对象
|运算符|step1|step2|step3|
|----|----|----|----|
|==,+|toString()|||
|-|valueOf()|||
|>,<|valueOf()|||

```
var now = new Date(); //创建一个日期对象
typeof(now + 1); // =>'string': "+" 将日期转换为字符串
typeof(now - 1); // =>'number': "-" 使用对象到数字的转换
now == now.toString() //=>true : 隐式的和显式的字符串转换
now > (now - 1);//=>true: ">"将日期转换成数字

```